{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar kontent_core_1 = require(\"@kentico/kontent-core\");\n\nvar config_1 = require(\"../config\");\n\nvar elements_1 = require(\"../elements\");\n\nvar models_1 = require(\"../models\");\n\nvar resolvers_1 = require(\"../resolvers\");\n\nvar ElementMapper =\n/** @class */\nfunction () {\n  function ElementMapper(config, richTextHtmlParser) {\n    this.config = config;\n    this.richTextHtmlParser = richTextHtmlParser;\n    this.defaultLinkedItemWrapperTag = 'p';\n    this.defaultLinkedItemWrapperClasses = ['kc-linked-item-wrapper'];\n  }\n  /**\r\n   * Maps all element in given content item and returns strongly typed content item based on the resolver specified\r\n   * in DeliveryClientConfig\r\n   */\n\n\n  ElementMapper.prototype.mapElements = function (data) {\n    var _this = this; // return processed item if possible (to avoid infinite recursion)\n\n\n    var processedItem = this.getProcessedItem(data.item.system.codename, data.processedItems);\n\n    if (processedItem) {\n      // item was already resolved, return it\n      return {\n        item: processedItem,\n        processedItems: data.processedItems,\n        preparedItems: data.preparedItems,\n        processingStartedForCodenames: data.processingStartedForCodenames\n      };\n    }\n\n    var elementCodenames = Object.getOwnPropertyNames(data.item.elements);\n    var itemInstance = resolvers_1.stronglyTypedResolver.createItemInstance(data.item.system.type, {\n      item: data.item,\n      modularContent: data.modularContent\n    }, this.config.typeResolvers || []);\n\n    if (!data.preparedItems) {\n      data.preparedItems = {};\n    } // add to prepared items\n\n\n    data.preparedItems[data.item.system.codename] = itemInstance;\n    elementCodenames.forEach(function (elementCodename) {\n      if (!itemInstance) {\n        throw Error(\"Item instance was not initiazed correctly.\");\n      }\n\n      var elementMap = _this.resolveElementMap(itemInstance, elementCodename);\n\n      var elementWrapper = {\n        contentItemSystem: data.item.system,\n        rawElement: data.item.elements[elementCodename],\n        propertyName: elementMap.resolvedName\n      };\n\n      if (elementMap.shouldMapElement) {\n        var mappedElement = _this.mapElement({\n          elementWrapper: elementWrapper,\n          item: itemInstance,\n          modularContent: data.modularContent,\n          preparedItems: data.preparedItems,\n          processingStartedForCodenames: data.processingStartedForCodenames,\n          processedItems: data.processedItems,\n          queryConfig: data.queryConfig\n        }); // set mapped element to item instance\n\n\n        itemInstance[elementMap.resolvedName] = mappedElement;\n      }\n    });\n    return {\n      item: itemInstance,\n      processedItems: data.processedItems,\n      preparedItems: data.preparedItems,\n      processingStartedForCodenames: data.processingStartedForCodenames\n    };\n  };\n\n  ElementMapper.prototype.mapElement = function (data) {\n    var elementType = kontent_core_1.enumHelper.getEnumFromValue(elements_1.ElementType, data.elementWrapper.rawElement.type);\n\n    if (elementType) {\n      if (elementType === elements_1.ElementType.ModularContent) {\n        return this.mapLinkedItemsElement({\n          elementWrapper: data.elementWrapper,\n          modularContent: data.modularContent,\n          preparedItems: data.preparedItems,\n          processingStartedForCodenames: data.processingStartedForCodenames,\n          processedItems: data.processedItems,\n          queryConfig: data.queryConfig\n        });\n      }\n\n      if (elementType === elements_1.ElementType.Text) {\n        return this.mapTextElement(data.elementWrapper);\n      }\n\n      if (elementType === elements_1.ElementType.Asset) {\n        return this.mapAssetsElement(data.elementWrapper);\n      }\n\n      if (elementType === elements_1.ElementType.Number) {\n        return this.mapNumberElement(data.elementWrapper);\n      }\n\n      if (elementType === elements_1.ElementType.MultipleChoice) {\n        return this.mapMultipleChoiceElement(data.elementWrapper);\n      }\n\n      if (elementType === elements_1.ElementType.DateTime) {\n        return this.mapDateTimeElement(data.elementWrapper);\n      }\n\n      if (elementType === elements_1.ElementType.RichText) {\n        return this.mapRichTextElement(data.item, data.elementWrapper, data.modularContent, data.queryConfig, data.processedItems, data.processingStartedForCodenames, data.preparedItems);\n      }\n\n      if (elementType === elements_1.ElementType.UrlSlug) {\n        return this.mapUrlSlugElement(data.elementWrapper, data.item, data.queryConfig);\n      }\n\n      if (elementType === elements_1.ElementType.Taxonomy) {\n        return this.mapTaxonomyElement(data.elementWrapper);\n      }\n\n      if (elementType === elements_1.ElementType.Custom) {\n        return this.mapCustomElement(data.elementWrapper);\n      }\n    }\n\n    console.warn(\"Could not map element '\" + data.elementWrapper.rawElement.name + \"' of type '\" + data.elementWrapper.rawElement.type + \"'. Returning unknown element instead.\");\n    return this.mapUnknowElement(data.elementWrapper);\n  };\n\n  ElementMapper.prototype.mapRichTextElement = function (item, elementWrapper, modularContent, queryConfig, processedItems, processingStartedForCodenames, preparedItems) {\n    var _this = this; // get all linked items nested in rich text\n\n\n    var richTextLinkedItems = [];\n    var rawElement = elementWrapper.rawElement;\n\n    if (rawElement.modular_content) {\n      if (Array.isArray(rawElement.modular_content)) {\n        rawElement.modular_content.forEach(function (codename) {\n          // get linked item and check if it exists (it might not be included in response due to 'Depth' parameter)\n          var rawItem = modularContent[codename]; // first try to get existing item\n\n          var existingLinkedItem = _this.getOrSaveLinkedItemForElement(codename, rawElement, queryConfig, modularContent, processedItems, processingStartedForCodenames, preparedItems);\n\n          if (existingLinkedItem) {\n            // item was found, add it to linked items\n            richTextLinkedItems.push(existingLinkedItem);\n          } else {\n            var throwErrorForMissingLinkedItems = false; // check if errors should be thrown for missing linked items\n\n            if (queryConfig.throwErrorForMissingLinkedItems === false || queryConfig.throwErrorForMissingLinkedItems === true) {\n              // variable is a boolean\n              throwErrorForMissingLinkedItems = queryConfig.throwErrorForMissingLinkedItems;\n            } // throw error if raw item is not available and errors are not skipped\n\n\n            if (!rawItem) {\n              var msg = \"Mapping RichTextElement element '\" + rawElement.name + \"' failed because referenced linked item with codename '\" + codename + \"' could not be found in Delivery response.\\n                            Increasing 'depth' parameter may solve this issue as it will include nested items. Alternatively you may disable 'throwErrorForMissingLinkedItems' in your query\";\n\n              if (throwErrorForMissingLinkedItems) {\n                throw Error(msg);\n              }\n            } // item was not found or not yet resolved\n\n\n            if (rawItem) {\n              var mappedLinkedItemResult = _this.mapElements({\n                item: rawItem,\n                modularContent: modularContent,\n                preparedItems: preparedItems,\n                processingStartedForCodenames: processingStartedForCodenames,\n                processedItems: processedItems,\n                queryConfig: queryConfig\n              }); // add mapped linked item to result\n\n\n              if (mappedLinkedItemResult) {\n                richTextLinkedItems.push(mappedLinkedItemResult.item);\n              }\n            }\n          }\n        });\n      }\n    } // extract and map links & images\n\n\n    var links = this.mapRichTextLinks(rawElement.links);\n    var images = this.mapRichTextImages(rawElement.images);\n    return new elements_1.Elements.RichTextElement(elementWrapper, rawElement.modular_content, {\n      links: links,\n      resolveRichTextFunc: function resolveRichTextFunc() {\n        return resolvers_1.richTextResolver.resolveData(item.system.codename, rawElement.value, elementWrapper.propertyName, {\n          enableAdvancedLogging: _this.config.isDeveloperMode ? _this.config.isDeveloperMode : false,\n          images: images,\n          richTextHtmlParser: _this.richTextHtmlParser,\n          getLinkedItem: function getLinkedItem(codename) {\n            return _this.getOrSaveLinkedItemForElement(codename, rawElement, queryConfig, modularContent, processedItems, processingStartedForCodenames, preparedItems);\n          },\n          links: links,\n          queryConfig: queryConfig,\n          linkedItemWrapperTag: _this.config.linkedItemResolver && _this.config.linkedItemResolver.linkedItemWrapperTag ? _this.config.linkedItemResolver.linkedItemWrapperTag : _this.defaultLinkedItemWrapperTag,\n          linkedItemWrapperClasses: _this.config.linkedItemResolver && _this.config.linkedItemResolver.linkedItemWrapperClasses ? _this.config.linkedItemResolver.linkedItemWrapperClasses : _this.defaultLinkedItemWrapperClasses\n        });\n      },\n      images: images\n    });\n  };\n\n  ElementMapper.prototype.mapDateTimeElement = function (elementWrapper) {\n    return new elements_1.Elements.DateTimeElement(elementWrapper);\n  };\n\n  ElementMapper.prototype.mapMultipleChoiceElement = function (elementWrapper) {\n    return new elements_1.Elements.MultipleChoiceElement(elementWrapper);\n  };\n\n  ElementMapper.prototype.mapNumberElement = function (elementWrapper) {\n    return new elements_1.Elements.NumberElement(elementWrapper);\n  };\n\n  ElementMapper.prototype.mapTextElement = function (elementWrapper) {\n    return new elements_1.Elements.TextElement(elementWrapper);\n  };\n\n  ElementMapper.prototype.mapAssetsElement = function (elementWrapper) {\n    return new elements_1.Elements.AssetsElement(elementWrapper);\n  };\n\n  ElementMapper.prototype.mapTaxonomyElement = function (elementWrapper) {\n    return new elements_1.Elements.TaxonomyElement(elementWrapper);\n  };\n\n  ElementMapper.prototype.mapUnknowElement = function (elementWrapper) {\n    return new elements_1.Elements.UnknownElement(elementWrapper);\n  };\n\n  ElementMapper.prototype.mapCustomElement = function (elementWrapper) {\n    // try to find element resolver\n    if (this.config.elementResolver) {\n      var customElementClass = this.config.elementResolver(elementWrapper);\n\n      if (customElementClass) {\n        return customElementClass;\n      }\n    }\n\n    return new elements_1.Elements.DefaultCustomElement(elementWrapper);\n  };\n\n  ElementMapper.prototype.mapUrlSlugElement = function (elementWrapper, item, queryConfig) {\n    var _this = this;\n\n    var resolver = this.getUrlSlugResolverForElement(item, elementWrapper, queryConfig);\n    return new elements_1.Elements.UrlSlugElement(elementWrapper, {\n      resolveLinkFunc: function resolveLinkFunc() {\n        return resolvers_1.urlSlugResolver.resolveUrl({\n          elementName: elementWrapper.propertyName,\n          elementValue: elementWrapper.rawElement.value,\n          item: item,\n          enableAdvancedLogging: _this.config.isDeveloperMode ? _this.config.isDeveloperMode : false,\n          resolver: resolver\n        }).url || '';\n      }\n    });\n  };\n\n  ElementMapper.prototype.mapLinkedItemsElement = function (data) {\n    var _this = this; // prepare linked items\n\n\n    var linkedItems = []; // value = array of item codenames\n\n    var linkedItemCodenames = data.elementWrapper.rawElement.value;\n    linkedItemCodenames.forEach(function (codename) {\n      var linkedItem = _this.getOrSaveLinkedItemForElement(codename, data.elementWrapper.rawElement, data.queryConfig, data.modularContent, data.processedItems, data.processingStartedForCodenames, data.preparedItems);\n\n      if (linkedItem) {\n        // add item to result\n        linkedItems.push(linkedItem);\n      } else {\n        // item was not found\n        if (_this.config.isDeveloperMode) {\n          // tslint:disable-next-line:max-line-length\n          console.warn(\"Linked item with codename '\" + codename + \"' in linked items element '\" + data.elementWrapper.rawElement.name + \"' of '\" + data.elementWrapper.rawElement.type + \"' type could not be found. If you require this item, consider increasing 'depth' of your query. This warning can be turned off by disabling 'enableAdvancedLogging' option.\");\n        }\n      }\n    });\n    return new elements_1.Elements.LinkedItemsElement(data.elementWrapper, linkedItems);\n  };\n\n  ElementMapper.prototype.getUrlSlugResolverForElement = function (item, elementWrapper, queryConfig) {\n    // query `urlSlugResolver` has priority over global resolver\n    if (queryConfig.urlSlugResolver) {\n      return queryConfig.urlSlugResolver;\n    }\n\n    if (item._config && item._config.urlSlugResolver) {\n      return item._config.urlSlugResolver;\n    } // resolve default link value\n\n\n    return function () {\n      return elementWrapper.rawElement.value;\n    };\n  };\n\n  ElementMapper.prototype.getProcessedItem = function (codename, processedItems) {\n    return processedItems[codename];\n  };\n\n  ElementMapper.prototype.getPreparedItem = function (codename, preparedItems) {\n    return preparedItems[codename];\n  };\n\n  ElementMapper.prototype.getOrSaveLinkedItemForElement = function (codename, element, queryConfig, modularContent, processedItems, mappingStartedForCodenames, preparedItems) {\n    // first check if item was already resolved and return it if it was\n    var processedItem = this.getProcessedItem(codename, processedItems);\n\n    if (processedItem) {\n      // item was already resolved\n      return processedItem;\n    }\n\n    if (mappingStartedForCodenames.find(function (m) {\n      return m === codename;\n    })) {\n      // item was already processed, but may not have yet been resolved (e.g. when child references parent)\n      // return reference to prepared item\n      return preparedItems[codename];\n    }\n\n    mappingStartedForCodenames.push(codename); // try getting item from modular content\n\n    var rawItem = modularContent[codename]; // if not found item might not be a linked item, but can still be in standard response\n    // (e.g. when linked item references item in standard response)\n\n    if (!rawItem) {\n      var preparedItem = this.getPreparedItem(codename, preparedItems);\n\n      if (preparedItem) {\n        return preparedItem;\n      }\n    } // by default errors are not thrown\n\n\n    var throwErrorForMissingLinkedItems = false; // check if errors should be thrown for missing linked items\n\n    if (queryConfig.throwErrorForMissingLinkedItems === false || queryConfig.throwErrorForMissingLinkedItems === true) {\n      // variable is a boolean\n      throwErrorForMissingLinkedItems = queryConfig.throwErrorForMissingLinkedItems;\n    } // throw error if item is not in response and errors are not skipped\n\n\n    if (!rawItem) {\n      if (throwErrorForMissingLinkedItems) {\n        throw Error(\"Linked item with codename '\" + codename + \"' could not be found in Delivery response.\\n                This linked item was requested by '\" + element.name + \"' element of '\" + element.type + \"'.\\n                Error can usually be solved by increasing 'Depth' parameter of your query.\\n                Alternatively, you may prevent this error by disabling 'throwErrorForMissingLinkedItems' in query configuration.\");\n      }\n\n      return undefined;\n    }\n\n    var mappedLinkedItem; // try resolving item using custom item resolver if its set\n\n    if (queryConfig.itemResolver) {\n      var customMappedItem = queryConfig.itemResolver(element, rawItem, modularContent, queryConfig);\n\n      if (customMappedItem) {\n        // if user used custom mapping, make sure to add 'system' and 'elements' properties to result\n        customMappedItem.system = resolvers_1.stronglyTypedResolver.mapSystemAttributes(rawItem.system);\n        customMappedItem.elements = rawItem.elements;\n        mappedLinkedItem = customMappedItem;\n      }\n    } // original resolving if item is still undefined\n\n\n    if (!mappedLinkedItem) {\n      var mappedLinkedItemResult = this.mapElements({\n        item: rawItem,\n        modularContent: modularContent,\n        preparedItems: preparedItems,\n        processingStartedForCodenames: mappingStartedForCodenames,\n        processedItems: processedItems,\n        queryConfig: queryConfig\n      });\n      mappedLinkedItem = mappedLinkedItemResult.item;\n    } // add to processed items\n\n\n    processedItems[codename] = mappedLinkedItem;\n    return mappedLinkedItem;\n  };\n\n  ElementMapper.prototype.mapRichTextLinks = function (linksJson) {\n    var links = [];\n\n    for (var _i = 0, _a = Object.keys(linksJson); _i < _a.length; _i++) {\n      var linkId = _a[_i];\n      var linkRaw = linksJson[linkId];\n      links.push(new models_1.Link({\n        codename: linkRaw.codename,\n        linkId: linkId,\n        urlSlug: linkRaw.url_slug,\n        type: linkRaw.type\n      }));\n    }\n\n    return links;\n  };\n\n  ElementMapper.prototype.mapRichTextImages = function (imagesJson) {\n    var images = [];\n\n    for (var _i = 0, _a = Object.keys(imagesJson); _i < _a.length; _i++) {\n      var imageId = _a[_i];\n      var imageRaw = imagesJson[imageId];\n      images.push(new models_1.RichTextImage({\n        description: imageRaw.description,\n        imageId: imageRaw.image_id,\n        url: imageRaw.url,\n        height: imageRaw.height,\n        width: imageRaw.width\n      }));\n    }\n\n    return images;\n  };\n\n  ElementMapper.prototype.resolveElementMap = function (item, originalElementCodename) {\n    var resolvedElementPropertyName = undefined; // resolve using property resolver\n\n    if (item._config && item._config.propertyResolver) {\n      resolvedElementPropertyName = item._config.propertyResolver(originalElementCodename);\n    } // if property hasn't been resolved, try getting name using decorator\n\n\n    if (resolvedElementPropertyName === originalElementCodename || !resolvedElementPropertyName) {\n      resolvedElementPropertyName = elements_1.ElementDecorators.getPropertyName(item, originalElementCodename);\n    }\n\n    if (!resolvedElementPropertyName) {\n      // use original element codename\n      resolvedElementPropertyName = originalElementCodename;\n    } // check for collissions\n\n\n    if (this.collidesWithAnotherProperty(resolvedElementPropertyName, item)) {\n      // try to resolve collission using dedicated resolver\n      var collisionResolver = this.getCollisionResolver();\n      resolvedElementPropertyName = collisionResolver(resolvedElementPropertyName); // verify again if the new element collides\n\n      if (this.collidesWithAnotherProperty(resolvedElementPropertyName, item)) {\n        console.warn(\"Element '\" + resolvedElementPropertyName + \"' collides with another element in same type. Element mapping is skipped. Source item: '\" + item.system.codename + \"'\");\n        return {\n          shouldMapElement: false,\n          resolvedName: ''\n        };\n      }\n    }\n\n    return {\n      resolvedName: resolvedElementPropertyName,\n      shouldMapElement: true\n    };\n  };\n\n  ElementMapper.prototype.getCollisionResolver = function () {\n    return this.config.collisionResolver ? this.config.collisionResolver : config_1.defaultCollissionResolver;\n  };\n\n  ElementMapper.prototype.collidesWithAnotherProperty = function (elementName, item) {\n    return item[elementName] ? true : false;\n  };\n\n  return ElementMapper;\n}();\n\nexports.ElementMapper = ElementMapper;","map":null,"metadata":{},"sourceType":"script"}