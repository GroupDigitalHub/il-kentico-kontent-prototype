"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var axios_1 = require("axios");
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var HttpFunctions = require("./http.functions");
var retry_service_1 = require("./retry-service");
var retry_strategy_1 = require("./retry-strategy");
var HttpService = /** @class */ (function () {
    function HttpService(opts) {
        this.axiosInstance = axios_1.default.create();
        if (opts) {
            if (opts.requestInterceptor) {
                HttpFunctions.registerRequestInterceptor(this.axiosInstance, (opts.requestInterceptor));
            }
            if (opts.responseInterceptor) {
                HttpFunctions.registerResponseInterceptor(this.axiosInstance, (opts.responseInterceptor));
            }
        }
    }
    /**
     * Retries given promise based on given configuration
     * @param promise Promise to retry
     * @param options Configuration options
     */
    HttpService.prototype.retryPromise = function (promise, options, currentAttempt) {
        var _this = this;
        if (currentAttempt === void 0) { currentAttempt = 1; }
        return new Promise(function (resolve, reject) { return promise
            .then(function (response) {
            resolve(response);
        })
            .catch(function (reason) {
            var statusCode = 0;
            if (reason && reason.originalError && reason.originalError.request) {
                statusCode = reason.originalError.request.status;
            }
            var retryCode = options.useRetryForResponseCodes.find(function (m) { return m === statusCode; });
            if (!retryCode && retryCode !== 0) {
                return reject(reason);
            }
            var retryTimeout = retry_service_1.retryService.getRetryTimeout(currentAttempt);
            if (currentAttempt <= options.maxRetryAttempts) {
                return _this.promiseRetryWait(retryTimeout)
                    .then(function () {
                    retry_service_1.retryService.debugLogAttempt(currentAttempt, retryTimeout);
                    return _this.retryPromise(promise, options, currentAttempt + 1);
                })
                    .then(function (response) { return resolve(response); })
                    .catch(function (error) { return reject(error); });
            }
            return reject(reason);
        }); });
    };
    HttpService.prototype.get = function (call, options) {
        // bind callback from axios promise
        var axiosObservable = rxjs_1.bindCallback(HttpFunctions.getCallback);
        // map axios observable
        return this.mapAxiosObservable(this.axiosInstance, axiosObservable, call, options);
    };
    HttpService.prototype.post = function (call, options) {
        // bind callback from axios promise
        var axiosObservable = rxjs_1.bindCallback(HttpFunctions.postCallback);
        // map axios observable
        return this.mapAxiosObservable(this.axiosInstance, axiosObservable, call, options);
    };
    HttpService.prototype.put = function (call, options) {
        // bind callback from axios promise
        var axiosObservable = rxjs_1.bindCallback(HttpFunctions.putCallback);
        // map axios observable
        return this.mapAxiosObservable(this.axiosInstance, axiosObservable, call, options);
    };
    HttpService.prototype.delete = function (call, options) {
        // bind callback from axios promise
        var axiosObservable = rxjs_1.bindCallback(HttpFunctions.deleteCallback);
        // map axios observable
        return this.mapAxiosObservable(this.axiosInstance, axiosObservable, call, options);
    };
    HttpService.prototype.mapAxiosObservable = function (axiosInstance, axiosObservable, call, options) {
        var _this = this;
        return axiosObservable(axiosInstance, call, options).pipe(operators_1.retryWhen(retry_strategy_1.retryStrategy.strategy({
            maxRetryAttempts: options && options.maxRetryAttempts ? options.maxRetryAttempts : 0,
            useRetryForResponseCodes: options && options.useRetryForResponseCodes
                ? options.useRetryForResponseCodes
                : []
        })), operators_1.map(function (result) { return _this.mapResult(result); }), operators_1.catchError(function (error) {
            // Handling errors: https://github.com/axios/axios#handling-errors
            if (options && options.logErrorToConsole) {
                console.warn("Kentico Kontent SDK encountered an error: ", error);
            }
            return rxjs_1.throwError({
                originalError: error,
                mappedError: call.mapError(error)
            });
        }));
    };
    HttpService.prototype.mapResult = function (result) {
        // if error is set, throw it
        if (result.error) {
            throw result.error;
        }
        // if neither error nor response is set, throw an error
        if (!result.response) {
            throw Error('Response is not set and no error was thrown');
        }
        return {
            data: result.response.data,
            response: result.response
        };
    };
    HttpService.prototype.promiseRetryWait = function (ms) {
        return new Promise(function (r) { return setTimeout(r, ms); });
    };
    return HttpService;
}());
exports.HttpService = HttpService;
//# sourceMappingURL=http.service.js.map