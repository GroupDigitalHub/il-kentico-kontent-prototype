import axios from 'axios';
import { bindCallback, throwError } from 'rxjs';
import { catchError, map, retryWhen } from 'rxjs/operators';
import * as HttpFunctions from './http.functions';
import { retryService } from './retry-service';
import { retryStrategy } from './retry-strategy';
var HttpService = /** @class */ (function () {
    function HttpService(opts) {
        this.axiosInstance = axios.create();
        if (opts) {
            if (opts.requestInterceptor) {
                HttpFunctions.registerRequestInterceptor(this.axiosInstance, (opts.requestInterceptor));
            }
            if (opts.responseInterceptor) {
                HttpFunctions.registerResponseInterceptor(this.axiosInstance, (opts.responseInterceptor));
            }
        }
    }
    /**
     * Retries given promise based on given configuration
     * @param promise Promise to retry
     * @param options Configuration options
     */
    HttpService.prototype.retryPromise = function (promise, options, currentAttempt) {
        var _this = this;
        if (currentAttempt === void 0) { currentAttempt = 1; }
        return new Promise(function (resolve, reject) { return promise
            .then(function (response) {
            resolve(response);
        })
            .catch(function (reason) {
            var statusCode = 0;
            if (reason && reason.originalError && reason.originalError.request) {
                statusCode = reason.originalError.request.status;
            }
            var retryCode = options.useRetryForResponseCodes.find(function (m) { return m === statusCode; });
            if (!retryCode && retryCode !== 0) {
                return reject(reason);
            }
            var retryTimeout = retryService.getRetryTimeout(currentAttempt);
            if (currentAttempt <= options.maxRetryAttempts) {
                return _this.promiseRetryWait(retryTimeout)
                    .then(function () {
                    retryService.debugLogAttempt(currentAttempt, retryTimeout);
                    return _this.retryPromise(promise, options, currentAttempt + 1);
                })
                    .then(function (response) { return resolve(response); })
                    .catch(function (error) { return reject(error); });
            }
            return reject(reason);
        }); });
    };
    HttpService.prototype.get = function (call, options) {
        // bind callback from axios promise
        var axiosObservable = bindCallback(HttpFunctions.getCallback);
        // map axios observable
        return this.mapAxiosObservable(this.axiosInstance, axiosObservable, call, options);
    };
    HttpService.prototype.post = function (call, options) {
        // bind callback from axios promise
        var axiosObservable = bindCallback(HttpFunctions.postCallback);
        // map axios observable
        return this.mapAxiosObservable(this.axiosInstance, axiosObservable, call, options);
    };
    HttpService.prototype.put = function (call, options) {
        // bind callback from axios promise
        var axiosObservable = bindCallback(HttpFunctions.putCallback);
        // map axios observable
        return this.mapAxiosObservable(this.axiosInstance, axiosObservable, call, options);
    };
    HttpService.prototype.delete = function (call, options) {
        // bind callback from axios promise
        var axiosObservable = bindCallback(HttpFunctions.deleteCallback);
        // map axios observable
        return this.mapAxiosObservable(this.axiosInstance, axiosObservable, call, options);
    };
    HttpService.prototype.mapAxiosObservable = function (axiosInstance, axiosObservable, call, options) {
        var _this = this;
        return axiosObservable(axiosInstance, call, options).pipe(retryWhen(retryStrategy.strategy({
            maxRetryAttempts: options && options.maxRetryAttempts ? options.maxRetryAttempts : 0,
            useRetryForResponseCodes: options && options.useRetryForResponseCodes
                ? options.useRetryForResponseCodes
                : []
        })), map(function (result) { return _this.mapResult(result); }), catchError(function (error) {
            // Handling errors: https://github.com/axios/axios#handling-errors
            if (options && options.logErrorToConsole) {
                console.warn("Kentico Kontent SDK encountered an error: ", error);
            }
            return throwError({
                originalError: error,
                mappedError: call.mapError(error)
            });
        }));
    };
    HttpService.prototype.mapResult = function (result) {
        // if error is set, throw it
        if (result.error) {
            throw result.error;
        }
        // if neither error nor response is set, throw an error
        if (!result.response) {
            throw Error('Response is not set and no error was thrown');
        }
        return {
            data: result.response.data,
            response: result.response
        };
    };
    HttpService.prototype.promiseRetryWait = function (ms) {
        return new Promise(function (r) { return setTimeout(r, ms); });
    };
    return HttpService;
}());
export { HttpService };
//# sourceMappingURL=http.service.js.map